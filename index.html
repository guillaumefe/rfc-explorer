<!DOCTYPE html>
<!--
  RFC Explorer
  A lightweight interface for browsing, pinning, and annotating IETF RFC documents.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RFC Explorer</title>
  <!-- Tailwind CSS for utility-first styling -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <!-- Ace Editor library for in-browser code/markdown viewing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/ace.js"></script>

  <style>
    /* Set default font */
    body { font-family: 'Inter', sans-serif; }
    /* Dashboard styling: light background */
    #dashboard { background-color: #f9fafb; }
    /* Individual RFC list items: card-like appearance */
    #dashboard li {
      background: #fff;
      border-radius: .5rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      padding: .75rem;
      position: relative;
    }
    /* Highlighted RFC entry */
    #dashboard li.highlight { background-color: #fef3c7; }
    /* Pulse animation for re-highlighting */
    #dashboard li.pulse { animation: pulse-highlight 0.5s ease-in-out; }
    @keyframes pulse-highlight {
      0% { background-color: #fef3c7; }
      50% { background-color: #fdba74; }
      100% { background-color: #fef3c7; }
    }
    /* Button hover effect in dashboard */
    #dashboard button { transition: background .2s; }
    #dashboard button:hover { background: #2563eb; }
    /* Header bar styling */
    #header { background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    /* Task card appearance */
    .task-card {
      background: #fff;
      border-radius: .5rem;
      padding: .75rem;
      margin-bottom: .75rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      cursor: pointer;
    }
    /* Nested subtask indent */
    .subtask-item { margin-left: 1.5rem; }
    /* Small button modifier */
    .btn-small { font-size: .75rem; padding: .25rem .5rem; border-radius: .25rem; }
    /* Highlight marker used by Ace editor for tasks */
    .ace_marker-layer .task-highlight, .ace_task-highlight {
      position: absolute;
      background-color: rgba(255,235,59,0.4);
    }
    /* Delete button styling */
    .btn-delete {
      font-size: 0.75rem;
      padding: 0.25rem;
      border-radius: 0.25rem;
      background: transparent;
      color: #e53e3e;
      transition: color .2s;
    }
    .btn-delete:hover { color: #c53030; }
  </style>
</head>

<body class="h-screen flex">
  <!-- Sidebar: RFC list, search box, pinned items -->
  <aside id="dashboard" class="w-1/4 border-r p-4 overflow-auto">
    <h2 class="text-2xl font-semibold mb-4">My RFCs</h2>
    <!-- Search input for filtering RFC list -->
    <input id="search" type="text" placeholder="Search…"
           class="w-full mb-4 p-2 rounded border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" />
    <!-- Pinned RFCs container -->
    <ul id="pinned-list" class="space-y-3 mb-6 max-h-48 overflow-y-auto"></ul>
    <!-- Dynamic RFC search results -->
    <ul id="rfc-list" class="space-y-3"></ul>

    <!-- Search tutorial displayed when input is empty -->
    <div id="search-tutorial" class="text-gray-600 italic p-4 bg-white rounded shadow mt-4">
      <p class="mb-2"><strong>Quick RFC Search Tips:</strong></p>
      <ol class="list-decimal list-inside space-y-1">
        <li>Type words separated by spaces to <em>AND</em> filter titles.</li>
        <li>Prefix a term with <code>+</code> to <em>OR</em> include.</li>
        <li>Prefix a term with <code>-</code> to exclude.</li>
        <li>Use <code>author:Name</code> or <code>status:draft</code> for field filters.</li>
        <li>Wrap phrases in quotes for exact matches (e.g. <code>"HTTP protocol"</code>).</li>
        <li>Combine these dorks to narrow or broaden your results.</li>
      </ol>
    </div>
  </aside>

  <!-- Main content area: header and Ace editor view -->
  <main class="flex-1 flex flex-col">
    <header id="header" class="p-4 border-b"><!-- Current RFC title injected here --></header>
    <div id="ace-editor" class="flex-1"></div>
  </main>

  <!-- Task pane: active and archived tasks for annotations -->
  <section id="task-pane" class="w-1/4 border-l p-4 overflow-auto">
    <h3 class="text-2xl font-semibold mb-4">Active Tasks</h3>
    <div id="active-tasks"></div>

    <h3 class="text-xl font-semibold mt-6 mb-2 flex justify-between items-center">
      Archived <span id="archived-count" class="bg-gray-300 text-gray-800 text-sm font-medium ml-2 px-2 py-1 rounded">0</span>
      <button id="toggle-archived" class="btn-small">Hide</button>
    </h3>
    <div id="archived-tasks" class="mb-4"></div>
  </section>

  <script>
    (function() {
      // Base API endpoint for fetching RFC metadata
      const baseApi = 'https://datatracker.ietf.org/api/v1/doc/document/?format=json&doc_type=rfc&limit=50';
      // State containers: all fetched RFCs, pinned list, active & archived tasks
      let rfcs = [],
          pinned = JSON.parse(localStorage.getItem('pinned') || '[]'),
          activeTasks = JSON.parse(localStorage.getItem('activeTasks') || '[]'),
          archivedTasks = JSON.parse(localStorage.getItem('archivedTasks') || '[]');
      let currentRfc = '';

      // Initialize Ace editor in read-only markdown mode
      const editor = ace.edit('ace-editor');
      const Range = ace.require('ace/range').Range;
      editor.setTheme('ace/theme/github');
      editor.session.setMode('ace/mode/markdown');
      editor.setReadOnly(true);

      /**
       * Construct the raw text URL for a given RFC or tracker document name.
       * @param {string} name - Identifier of the RFC (e.g., "rfc1234").
       * @returns {string} URL pointing to the plaintext RFC.
       */
      function constructDocUrl(name) {
        const m = name.match(/^rfc(\d+)$/i);
        if (m) {
          return `https://www.rfc-editor.org/rfc/rfc${m[1]}.txt`;
        } else {
          return `https://datatracker.ietf.org/doc/${name}/`;
        }
      }

      /**
       * Render the list of pinned RFCs in the sidebar.
       */
      function renderPinned() {
        const ul = document.getElementById('pinned-list');
        const prevScroll = ul.scrollTop;
        ul.innerHTML = '';
        pinned.forEach(r => {
          const li = document.createElement('li');
          li.className = 'flex justify-between items-center';
          li.innerHTML = `
            <span class="font-medium text-gray-700">${r.name}</span>
            <div class="flex items-center space-x-1">
              <button data-name="${r.name}" class="bg-green-600 text-white btn-small">Open</button>
              <button data-del-pin="${r.name}" class="btn-delete">&times;</button>
            </div>
          `;
          ul.appendChild(li);
        });
        ul.scrollTop = prevScroll;
      }

      // Save pinned RFCs to localStorage and re-render
      function savePinned() {
        localStorage.setItem('pinned', JSON.stringify(pinned));
        renderPinned();
      }

      /**
       * Render a given array of RFC metadata into the main list.
       * @param {Array} items - RFC objects fetched from API.
       */
      function renderList(items) {
        rfcs = items;
        const ul = document.getElementById('rfc-list');
        const prevScroll = ul.scrollTop;
        ul.innerHTML = '';
        items.forEach(r => {
          const li = document.createElement('li');
          li.className = 'flex justify-between items-center';
          li.innerHTML = `
            <span class="text-gray-800">${r.name} — ${r.title}</span>
            <div class="flex items-center space-x-1">
              <button data-name="${r.name}" class="bg-blue-600 text-white btn-small">Download</button>
              <button data-del-rfc="${r.name}" class="btn-delete">&times;</button>
            </div>
          `;
          ul.appendChild(li);
        });
        ul.scrollTop = prevScroll;
      }

      /**
       * Parse search query string into logical filters (AND, OR, excludes, exact phrases, field filters).
       * @param {string} q - Raw search input.
       * @returns {Object} Parsed tokens and filter criteria.
       */
      function parseDorks(q) {
        const tokens = q.match(/(?:[+-]?"[^"]*")|[+-]?\S+/g) || [];
        const andTerms = [], orTerms = [], exclude = [], filters = {}, exact = [];
        tokens.forEach(tok => {
          let sign = null, core = tok;
          if (tok[0] === '+' || tok[0] === '-') { sign = tok[0]; core = tok.slice(1); }
          if (/^".*"$/.test(core)) {
            const phrase = core.slice(1, -1);
            exact.push(phrase);
            (sign === '-') ? exclude.push(phrase) : andTerms.push(phrase);
          } else if (/^\w+:/.test(core)) {
            const [field, val] = core.split(':');
            filters[field] = filters[field] || { include: [], exclude: [] };
            (sign === '-') ? filters[field].exclude.push(val) : filters[field].include.push(val);
          } else if (sign === '-') {
            exclude.push(core);
          } else {
            (sign === '+' ? orTerms : andTerms).push(core);
          }
        });
        return { andTerms, orTerms, exclude, filters, exact };
      }

      // Reference to search input and tutorial display
      const searchInput = document.getElementById('search');
      const tutorialDiv = document.getElementById('search-tutorial');

      searchInput.addEventListener('input', e => {
        const q = e.target.value.trim().toLowerCase();
        if (!q) {
          renderList([]);
          tutorialDiv.classList.remove('hidden');
          return;
        }
        tutorialDiv.classList.add('hidden');

        // 1) If it's just a number (e.g. "1234") or "rfc1234", search by name__iexact
        const m = q.match(/^(?:rfc)?(\d+)$/);
        if (m) {
          const name = 'rfc' + m[1];
          fetch(`${baseApi}&name__iexact=${encodeURIComponent(name)}`, { mode: 'cors' })
            .then(r => r.ok
              ? r.json().then(d => renderList(d.objects || []))
              : renderList([])
            )
            .catch(() => renderList([]));
          return;
        }

        // 2) Otherwise, perform full-text search on the title
        const { andTerms, orTerms, exclude, filters, exact } = parseDorks(q);

        const fetchFor = term =>
          fetch(`${baseApi}&title__icontains=${encodeURIComponent(term)}`, { mode: 'cors' })
            .then(r => r.ok
              ? r.json().then(d => d.objects || [])
              : []
            );

        // Combined full-text search using both AND and OR
        const fetchPromises = [];

        // If there are AND terms, perform a single grouped AND request
        if (andTerms.length) {
          const urlAND = andTerms.reduce(
            (u, term) => `${u}&title__icontains=${encodeURIComponent(term)}`,
            baseApi
          );
          fetchPromises.push(
            fetch(urlAND, { mode: 'cors' })
              .then(r => r.ok ? r.json().then(d => d.objects || []) : [])
          );
        }

        // If there are OR terms, perform one request per term
        orTerms.forEach(term => {
          fetchPromises.push(fetchFor(term));
        });

        // Wait for all requests, then merge and filter results
        Promise.all(fetchPromises)
          .then(arrays => {
            // flatten and deduplicate by RFC name
            let merged = Array.from(
              new Map(arrays.flat().map(r => [r.name, r])).values()
            );
            // (optional) if both AND and OR present, reapply AND filter to be safe
            if (andTerms.length && orTerms.length) {
              merged = merged.filter(r =>
                andTerms.every(term =>
                  r.title.toLowerCase().includes(term)
                )
              );
            }
            applyClientFilters(merged);
          })
          .catch(() => renderList([]));

        // 3) Post-processing: exact matches, exclusions and field filters
        function applyClientFilters(results) {
          if (exact.length) {
            results = results.filter(r =>
              exact.every(ph => r.title.toLowerCase().includes(ph))
            );
          }
          if (exclude.length) {
            results = results.filter(r =>
              exclude.every(ex =>
                !(r.title + ' ' + r.name).toLowerCase().includes(ex)
              )
            );
          }
          Object.entries(filters).forEach(([field, { include: incs, exclude: excs }]) => {
            if (incs.length) {
              results = results.filter(r =>
                incs.some(val => String(r[field]).toLowerCase() === val)
              );
            }
            if (excs.length) {
              results = results.filter(r =>
                excs.every(val => String(r[field]).toLowerCase() !== val)
              );
            }
          });
          renderList(results);
        }
      });

      // Delegate clicks on RFC list: pin/open or delete
      document.getElementById('rfc-list').addEventListener('click', e => {
        if (e.target.tagName === 'BUTTON' && e.target.dataset.name) {
          const name = e.target.dataset.name;
          const item = rfcs.find(r => r.name === name);
          if (item && !pinned.some(p => p.name === name)) {
            pinned.push(item);
            savePinned();
          }
          fetchAndRender(name);
          highlightRfc(name);
        }
        if (e.target.dataset.delRfc) {
          rfcs = rfcs.filter(r => r.name !== e.target.dataset.delRfc);
          renderList(rfcs);
        }
      });

      // Delegate clicks on pinned list: open or remove pin
      document.getElementById('pinned-list').addEventListener('click', e => {
        if (e.target.tagName === 'BUTTON' && e.target.dataset.name) {
          fetchAndRender(e.target.dataset.name);
          highlightRfc(e.target.dataset.name);
        }
        if (e.target.dataset.delPin) {
          pinned = pinned.filter(r => r.name !== e.target.dataset.delPin);
          savePinned();
        }
      });

      /**
       * Display active tasks or an onboarding placeholder if none exist.
       */
      function renderActiveTasks() {
        const container = document.getElementById('active-tasks');
        const prevScroll = container.scrollTop;
        container.innerHTML = '';
        if (activeTasks.length === 0) {
          container.innerHTML = `
            <div class="text-gray-600 italic p-4 bg-white rounded shadow">
              <p class="mb-2">1. Select text in the editor to create a new task.</p>
              <p class="mb-2">2. Click the “+” button to add it under Active Tasks.</p>
              <p>3. Use the checkbox to mark tasks done and archive them.</p>
            </div>
          `;
        } else {
          activeTasks.forEach((t,i) => {
            const card = document.createElement('div');
            card.className = 'task-card';
            card.dataset.rfc = t.rfc;
            // Render main task and subtasks with checkboxes and delete buttons
            card.innerHTML = `
              <div class="flex justify-between items-center">
                <h4 class="font-medium flex-1">
                  <input type="checkbox" data-ti="${i}" class="mr-2" /> ${t.text}
                </h4>
                <button data-del-task="${i}" class="btn-delete">&times;</button>
              </div>
              ${t.subtasks.map((st,j) => `
                <div class="subtask-item flex items-center justify-between">
                  <div class="flex items-center">
                    <input type="checkbox" data-sti="${i}-${j}" class="mr-2" />${st.text}
                  </div>
                  <button data-del-subtask="${i}-${j}" class="btn-delete">&times;</button>
                </div>
              `).join('')}
              <button data-si="${i}" class="text-blue-600 btn-small mt-2">+ Subtask</button>
            `;
            container.appendChild(card);
          });
        }
        container.scrollTop = prevScroll;
        if (activeTasks.length > 0) bindTaskEvents();
      }

      /**
       * Display archived tasks and update archive count.
       */
      function renderArchivedTasks() {
        const container = document.getElementById('archived-tasks');
        const prevScroll = container.scrollTop;
        document.getElementById('archived-count').textContent = archivedTasks.length;
        container.innerHTML = '';
        archivedTasks.forEach((t,i) => {
          const card = document.createElement('div');
          card.className = 'task-card';
          card.dataset.rfc = t.rfc;
          card.innerHTML = `
            <div class="flex items-center justify-between">
              <div class="flex items-center">
                <input type="checkbox" data-ai="${i}" class="mr-2" checked />
                <span>${t.text}</span>
              </div>
              <button class="archive-toggle text-xs px-1 py-0.5 ml-2">▶</button>
            </div>
            <div class="archived-subtasks hidden ml-8 mt-2">
              ${t.subtasks.map((st,j) => `
                <div class="subtask-item flex items-center">`
           + `<input type="checkbox" data-sti="${i}-${j}" class="mr-2" ${st.done ? 'checked' : ''} /> ${st.text}`
           + `</div>`
              ).join('')}
            </div>
          `;
          container.appendChild(card);
        });
        bindArchiveEvents();
        container.scrollTop = prevScroll;
      }

      // Attach change and click handlers for active task interactions
      function bindTaskEvents() {
        document.querySelectorAll('#active-tasks input[data-ti]').forEach(cb => {
          cb.addEventListener('change', e => {
            const i = Number(e.target.dataset.ti);
            const task = activeTasks.splice(i,1)[0];
            archivedTasks.unshift(task);
            saveTasks();
          });
        });
        document.querySelectorAll('#active-tasks button[data-si]').forEach(btn => {
          btn.addEventListener('click', e => {
            const i = Number(e.target.dataset.si);
            const text = prompt(`Add a subtask for "${activeTasks[i].text}"`);
            if (text) {
              activeTasks[i].subtasks.push({ text, done: false });
              saveTasks();
            }
          });
        });
        document.querySelectorAll('#active-tasks .task-card').forEach(card => {
          card.addEventListener('click', e => {
            if (['INPUT','BUTTON'].includes(e.target.tagName)) return;
            highlightRfc(card.dataset.rfc);
          });
        });
      }

      // Global click handlers for deleting tasks/subtasks
      document.getElementById('active-tasks').addEventListener('click', e => {
        if (e.target.dataset.delTask !== undefined) {
          activeTasks.splice(Number(e.target.dataset.delTask),1);
          saveTasks();
        }
        if (e.target.dataset.delSubtask) {
          const [a,b] = e.target.dataset.delSubtask.split('-').map(Number);
          activeTasks[a].subtasks.splice(b,1);
          saveTasks();
        }
      });
      document.getElementById('archived-tasks').addEventListener('click', e => {
        if (e.target.dataset.delArchTask !== undefined) {
          archivedTasks.splice(Number(e.target.dataset.delArchTask),1);
          saveTasks();
        }
        if (e.target.dataset.delArchSubtask) {
          const [a,b] = e.target.dataset.delArchSubtask.split('-').map(Number);
          archivedTasks[a].subtasks.splice(b,1);
          saveTasks();
        }
      });

      // Toggle archived subtasks visibility and reactivation
      function bindArchiveEvents() {
        document.querySelectorAll('#archived-tasks input[data-ai]').forEach(cb => {
          cb.addEventListener('change', e => {
            const i = Number(e.target.dataset.ai);
            const task = archivedTasks.splice(i,1)[0];
            activeTasks.unshift(task);
            saveTasks();
          });
        });
        document.querySelectorAll('.archive-toggle').forEach(btn => {
          btn.addEventListener('click', () => {
            const subtasksDiv = btn.closest('.task-card').querySelector('.archived-subtasks');
            const open = !subtasksDiv.classList.toggle('hidden');
            btn.textContent = open ? '▼' : '▶';
          });
        });
        document.querySelectorAll('#archived-tasks .task-card').forEach(card => {
          card.addEventListener('click', e => {
            if (['INPUT','BUTTON'].includes(e.target.tagName)) return;
            highlightRfc(card.dataset.rfc);
          });
        });
      }

      // Persist tasks to localStorage and rerender everything
      function saveTasks() {
        localStorage.setItem('activeTasks', JSON.stringify(activeTasks));
        localStorage.setItem('archivedTasks', JSON.stringify(archivedTasks));
        renderActiveTasks();
        renderArchivedTasks();
        highlightEditorTasks();
      }

      /**
       * Add a new active task tied to current RFC and selected text range.
       */
      function addTask(text, range) {
        activeTasks.unshift({ text, done: false, subtasks: [], rfc: currentRfc, range });
        saveTasks();
      }

      // Toggle archived tasks pane visibility
      document.getElementById('toggle-archived').addEventListener('click', () => {
        document.getElementById('archived-tasks').classList.toggle('hidden');
      });

      // Highlight the corresponding RFC entry in the sidebar
      let lastHighlighted = null;
      function highlightRfc(name) {
        const btn = document.querySelector(`#dashboard button[data-name=\"${name}\"]`);
        if (!btn) return;
        const li = btn.closest('li');
        if (name === lastHighlighted) {
          li.classList.remove('pulse'); void li.offsetWidth; li.classList.add('pulse');
        } else {
          document.querySelectorAll('#dashboard li').forEach(el => el.classList.remove('highlight','pulse'));
          li.classList.add('highlight');
          lastHighlighted = name;
        }
      }

      /**
       * Render highlight markers in the Ace editor for any tasks tied to the current RFC.
       */
      function highlightEditorTasks() {
        // Remove existing task markers
        Object.values(editor.session.getMarkers(false)).forEach(m => {
          if (m.clazz === 'task-highlight') editor.session.removeMarker(m.id);
        });
        // Add markers for all tasks belonging to the current document
        activeTasks.concat(archivedTasks).forEach(t => {
          if (t.rfc === currentRfc && t.range) {
            const { startRow, startCol, endRow, endCol } = t.range;
            editor.session.addMarker(new Range(startRow,startCol,endRow,endCol), 'task-highlight', 'text', false);
          }
        });
      }

      // Show "+" button when text is selected in the editor
      editor.container.addEventListener('mouseup', () => {
        setTimeout(() => {
          const sel = editor.getSelectedText();
          let btn = document.getElementById('task-add-btn');
          if (sel) {
            const range = editor.getSelectionRange();
            const c = editor.renderer.textToScreenCoordinates(range.start.row, range.start.column);
            if (!btn) {
              btn = document.createElement('button');
              btn.id = 'task-add-btn';
              btn.textContent = '+';
              btn.className = 'absolute bg-blue-600 text-white rounded-full w-6 h-6';
              document.body.appendChild(btn);
            }
            btn.style.top = (c.pageY - 8) + 'px';
            btn.style.left = (c.pageX - 8) + 'px';
            btn.onclick = () => { addTask(sel, range); btn.remove(); editor.clearSelection(); };
          } else if (btn) {
            btn.remove();
          }
        }, 10);
      });

      /**
       * Fetch and render an RFC document by name, update editor and tasks.
       * @param {string} name - RFC identifier (e.g., "rfc822").
       */
      function fetchAndRender(name) {
        currentRfc = name;
        const rawUrl = constructDocUrl(name);
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(rawUrl)}`;
        fetch(proxyUrl)
          .then(r => r.ok ? r.text() : Promise.reject())
          .then(t => {
            document.getElementById('header').innerHTML = `<h1 class="text-2xl font-bold text-gray-900 p-4">${name}</h1>`;
            editor.session.setValue(t, -1);
            renderActiveTasks();
            renderArchivedTasks();
            highlightEditorTasks();
          })
          .catch(() => { editor.session.setValue('Error loading.', -1); });
      }

      // Initial rendering of pinned items and tasks on page load
      renderPinned();
      renderActiveTasks();
      renderArchivedTasks();
    })();
  </script>
</body>
</html>
